import {
  createPR,
  findPRs,
  updatePR,
  type PRInfo,
  remoteBranchExists,
  push,
  getCurrentBranch,
  checkoutBranch,
  createOrphanBranch,
  removeAllFiles,
  commitAllowEmpty,
  rebaseBranch,
  abortRebase,
  setRepositoryDefaultBranch,
} from "@openTiger/vcs";
import { getRepoMode } from "@openTiger/core";
import type { Task } from "@openTiger/core";

export interface CreatePROptions {
  repoPath: string; // Repository path
  branchName: string;
  task: Task;
  baseBranch?: string;
  changedFiles: string[];
  stats: { additions: number; deletions: number };
  verificationResults: Array<{ command: string; success: boolean }>;
}

export interface CreatePRResult {
  success: boolean;
  pr?: PRInfo;
  isUpdate?: boolean;
  error?: string;
}

// Generate PR body
function generatePRBody(options: CreatePROptions): string {
  const { task, changedFiles, stats, verificationResults } = options;
  const issue = task.context?.issue;

  const lines: string[] = ["## Summary", "", task.goal, ""];

  if (issue?.number) {
    lines.push(`Closes #${issue.number}`, "");
  }

  // Task information
  lines.push(
    "## Task Details",
    "",
    `- **Task ID**: \`${task.id}\``,
    `- **Risk Level**: ${task.riskLevel}`,
    `- **Timebox**: ${task.timeboxMinutes} minutes`,
    "",
  );
  if (issue?.number) {
    const issueLine = issue.url
      ? `- **Issue**: #${issue.number} (${issue.url})`
      : `- **Issue**: #${issue.number}`;
    lines.splice(lines.length - 1, 0, issueLine);
  }

  // Change stats
  lines.push(
    "## Changes",
    "",
    `**${changedFiles.length}** files changed, **${stats.additions}** insertions(+), **${stats.deletions}** deletions(-)`,
    "",
  );

  // Changed files list
  if (changedFiles.length > 0) {
    lines.push("<details>", "<summary>Changed files</summary>", "");
    for (const file of changedFiles) {
      lines.push(`- \`${file}\``);
    }
    lines.push("", "</details>", "");
  }

  // Verification result
  lines.push("## Verification", "");
  for (const result of verificationResults) {
    const icon = result.success ? "✅" : "❌";
    lines.push(`${icon} \`${result.command}\``);
  }
  lines.push("");

  // Auto-generated labels
  lines.push(
    "---",
    "",
    "_This PR was automatically generated by openTiger._",
    "",
    `Labels: \`agent\`, \`${task.riskLevel}-risk\``,
  );

  return lines.join("\n");
}

// Ensure base branch on remote before pushing agent branch
export async function ensureRemoteBaseBranch(
  repoPath: string,
  baseBranch: string,
  currentBranch: string,
): Promise<{ success: boolean; created: boolean; error?: string }> {
  if (getRepoMode() !== "github") {
    return { success: true, created: false };
  }

  const baseExists = await remoteBranchExists(repoPath, baseBranch);
  if (baseExists) {
    try {
      await setRepositoryDefaultBranch(baseBranch);
      return { success: true, created: false };
    } catch (error) {
      return {
        success: false,
        created: false,
        error: `Failed to set default branch to ${baseBranch}: ${error instanceof Error ? error.message : String(error)}`,
      };
    }
  }

  const originalBranch = (await getCurrentBranch(repoPath)) ?? currentBranch;

  // For empty repo: create base via orphan, rebase currentBranch to avoid
  // PR "No commits between" and "no history in common"
  console.log(`[Worker] Base branch ${baseBranch} does not exist on remote. Bootstrapping...`);

  const orphanResult = await createOrphanBranch(repoPath, baseBranch);
  if (!orphanResult.success) {
    return {
      success: false,
      created: false,
      error: `Failed to create orphan branch: ${orphanResult.stderr}`,
    };
  }

  const cleanupResult = await removeAllFiles(repoPath);
  if (!cleanupResult.success && cleanupResult.stderr.trim().length > 0) {
    console.warn(`[Worker] Cleanup warning while creating ${baseBranch}: ${cleanupResult.stderr}`);
  }

  const commitResult = await commitAllowEmpty(repoPath, "chore: initialize default branch");
  if (!commitResult.success) {
    await checkoutBranch(repoPath, originalBranch);
    return {
      success: false,
      created: false,
      error: `Failed to create base commit: ${commitResult.stderr}`,
    };
  }

  const pushBaseResult = await push(repoPath, baseBranch);
  if (!pushBaseResult.success) {
    await checkoutBranch(repoPath, originalBranch);
    return {
      success: false,
      created: false,
      error: `Failed to push base branch: ${pushBaseResult.stderr}`,
    };
  }

  try {
    await setRepositoryDefaultBranch(baseBranch);
    console.log(`[Worker] Repository default branch set to ${baseBranch}.`);
  } catch (error) {
    await checkoutBranch(repoPath, originalBranch);
    return {
      success: false,
      created: false,
      error: `Failed to set default branch to ${baseBranch}: ${error instanceof Error ? error.message : String(error)}`,
    };
  }

  const restoreResult = await checkoutBranch(repoPath, originalBranch);
  if (!restoreResult.success) {
    return {
      success: false,
      created: false,
      error: `Failed to restore branch ${originalBranch}: ${restoreResult.stderr}`,
    };
  }

  const rebaseResult = await rebaseBranch(repoPath, baseBranch);
  if (!rebaseResult.success) {
    await abortRebase(repoPath);
    return {
      success: false,
      created: false,
      error: `Failed to rebase ${originalBranch} onto ${baseBranch}: ${rebaseResult.stderr}`,
    };
  }

  // Force update currentBranch as rebase changes history
  const pushBranchResult = await push(repoPath, `${originalBranch}:${originalBranch}`, true);
  if (!pushBranchResult.success) {
    return {
      success: false,
      created: false,
      error: `Failed to push rebased branch ${originalBranch}: ${pushBranchResult.stderr}`,
    };
  }

  console.log(`[Worker] Base branch ${baseBranch} created and pushed.`);
  return { success: true, created: true };
}

// Create or update PR
export async function createTaskPR(options: CreatePROptions): Promise<CreatePRResult> {
  const repoMode = getRepoMode();
  if (repoMode !== "github") {
    console.log(`${repoMode} mode: skipping PR creation`);
    return {
      success: true,
      isUpdate: false,
    };
  }
  const { branchName, task, baseBranch = "main" } = options;

  console.log("Checking for existing PR...");

  const title = `[openTiger] ${task.title}`;
  const body = generatePRBody(options);

  // Labels by risk level
  const labels = ["agent", "autogen", `${task.riskLevel}-risk`];

  try {
    // Find existing PR (PR from same branch)
    const existingPRs = await findPRs({
      head: branchName,
      base: baseBranch,
      state: "open",
    });

    if (existingPRs.length > 0 && existingPRs[0]) {
      const existingPR = existingPRs[0];
      console.log(`Updating existing PR #${existingPR.number}...`);

      const pr = await updatePR(existingPR.number, {
        title,
        body,
        labels,
      });

      return {
        success: true,
        pr,
        isUpdate: true,
      };
    }

    console.log("Creating new PR...");
    const pr = await createPR({
      title,
      body,
      head: branchName,
      base: baseBranch,
      labels,
      // Draft PRs delay merge throughput in autonomous mode.
      draft: false,
    });

    console.log(`PR created: ${pr.url}`);

    return {
      success: true,
      pr,
      isUpdate: false,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.error("Failed to create/update PR:", message);

    return {
      success: false,
      error: message,
    };
  }
}
