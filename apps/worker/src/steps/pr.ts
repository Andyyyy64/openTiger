import {
  createPR,
  findPRs,
  updatePR,
  type PRInfo,
  remoteBranchExists,
  push,
  getCurrentBranch,
  checkoutBranch,
  createOrphanBranch,
  removeAllFiles,
  commitAllowEmpty,
  rebaseBranch,
  abortRebase,
  setRepositoryDefaultBranch,
} from "@openTiger/vcs";
import { getRepoMode } from "@openTiger/core";
import type { Task } from "@openTiger/core";

export interface CreatePROptions {
  repoPath: string; // リポジトリパスを追加
  branchName: string;
  task: Task;
  baseBranch?: string;
  changedFiles: string[];
  stats: { additions: number; deletions: number };
  verificationResults: Array<{ command: string; success: boolean }>;
}

export interface CreatePRResult {
  success: boolean;
  pr?: PRInfo;
  isUpdate?: boolean;
  error?: string;
}

// PR本文を生成
function generatePRBody(options: CreatePROptions): string {
  const { task, changedFiles, stats, verificationResults } = options;
  const issue = task.context?.issue;

  const lines: string[] = [
    "## Summary",
    "",
    task.goal,
    "",
  ];

  if (issue?.number) {
    lines.push(`Closes #${issue.number}`, "");
  }

  // Task information
  lines.push(
    "## Task Details",
    "",
    `- **Task ID**: \`${task.id}\``,
    `- **Risk Level**: ${task.riskLevel}`,
    `- **Timebox**: ${task.timeboxMinutes} minutes`,
    ""
  );
  if (issue?.number) {
    const issueLine = issue.url
      ? `- **Issue**: #${issue.number} (${issue.url})`
      : `- **Issue**: #${issue.number}`;
    lines.splice(lines.length - 1, 0, issueLine);
  }

  // 変更統計
  lines.push(
    "## Changes",
    "",
    `**${changedFiles.length}** files changed, **${stats.additions}** insertions(+), **${stats.deletions}** deletions(-)`,
    ""
  );

  // 変更ファイル一覧
  if (changedFiles.length > 0) {
    lines.push("<details>", "<summary>Changed files</summary>", "");
    for (const file of changedFiles) {
      lines.push(`- \`${file}\``);
    }
    lines.push("", "</details>", "");
  }

  // 検証結果
  lines.push("## Verification", "");
  for (const result of verificationResults) {
    const icon = result.success ? "✅" : "❌";
    lines.push(`${icon} \`${result.command}\``);
  }
  lines.push("");

  // 自動生成ラベル
  lines.push(
    "---",
    "",
    "_This PR was automatically generated by openTiger._",
    "",
    `Labels: \`agent\`, \`${task.riskLevel}-risk\``
  );

  return lines.join("\n");
}

// agent ブランチを push する前にベースブランチをリモートに確保する
export async function ensureRemoteBaseBranch(
  repoPath: string,
  baseBranch: string,
  currentBranch: string
): Promise<{ success: boolean; created: boolean; error?: string }> {
  if (getRepoMode() === "local") {
    return { success: true, created: false };
  }

  const baseExists = await remoteBranchExists(repoPath, baseBranch);
  if (baseExists) {
    try {
      await setRepositoryDefaultBranch(baseBranch);
      return { success: true, created: false };
    } catch (error) {
      return {
        success: false,
        created: false,
        error: `Failed to set default branch to ${baseBranch}: ${error instanceof Error ? error.message : String(error)}`,
      };
    }
  }

  const originalBranch = (await getCurrentBranch(repoPath)) ?? currentBranch;

  // 空リポジトリ時は orphan で base を作り、currentBranch を rebase して
  // PRの「No commits between」「no history in common」を同時に防ぐ
  console.log(`[Worker] Base branch ${baseBranch} does not exist on remote. Bootstrapping...`);

  const orphanResult = await createOrphanBranch(repoPath, baseBranch);
  if (!orphanResult.success) {
    return { success: false, created: false, error: `Failed to create orphan branch: ${orphanResult.stderr}` };
  }

  const cleanupResult = await removeAllFiles(repoPath);
  if (!cleanupResult.success && cleanupResult.stderr.trim().length > 0) {
    console.warn(`[Worker] Cleanup warning while creating ${baseBranch}: ${cleanupResult.stderr}`);
  }

  const commitResult = await commitAllowEmpty(repoPath, "chore: initialize default branch");
  if (!commitResult.success) {
    await checkoutBranch(repoPath, originalBranch);
    return { success: false, created: false, error: `Failed to create base commit: ${commitResult.stderr}` };
  }

  const pushBaseResult = await push(repoPath, baseBranch);
  if (!pushBaseResult.success) {
    await checkoutBranch(repoPath, originalBranch);
    return { success: false, created: false, error: `Failed to push base branch: ${pushBaseResult.stderr}` };
  }

  try {
    await setRepositoryDefaultBranch(baseBranch);
    console.log(`[Worker] Repository default branch set to ${baseBranch}.`);
  } catch (error) {
    await checkoutBranch(repoPath, originalBranch);
    return {
      success: false,
      created: false,
      error: `Failed to set default branch to ${baseBranch}: ${error instanceof Error ? error.message : String(error)}`,
    };
  }

  const restoreResult = await checkoutBranch(repoPath, originalBranch);
  if (!restoreResult.success) {
    return { success: false, created: false, error: `Failed to restore branch ${originalBranch}: ${restoreResult.stderr}` };
  }

  const rebaseResult = await rebaseBranch(repoPath, baseBranch);
  if (!rebaseResult.success) {
    await abortRebase(repoPath);
    return {
      success: false,
      created: false,
      error: `Failed to rebase ${originalBranch} onto ${baseBranch}: ${rebaseResult.stderr}`,
    };
  }

  // Force update currentBranch as rebase changes history
  const pushBranchResult = await push(repoPath, `${originalBranch}:${originalBranch}`, true);
  if (!pushBranchResult.success) {
    return {
      success: false,
      created: false,
      error: `Failed to push rebased branch ${originalBranch}: ${pushBranchResult.stderr}`,
    };
  }

  console.log(`[Worker] Base branch ${baseBranch} created and pushed.`);
  return { success: true, created: true };
}

// PRを作成または更新
export async function createTaskPR(
  options: CreatePROptions
): Promise<CreatePRResult> {
  const repoMode = getRepoMode();
  if (repoMode === "local") {
    console.log("Local mode: skipping PR creation");
    return {
      success: true,
      isUpdate: false,
    };
  }
  const { repoPath, branchName, task, baseBranch = "main" } = options;

  console.log("Checking for existing PR...");

  const title = `[openTiger] ${task.title}`;
  const body = generatePRBody(options);

  // リスクレベルに応じたラベル
  const labels = ["agent", "autogen", `${task.riskLevel}-risk`];

  try {
    // Find existing PR (PR from same branch)
    const existingPRs = await findPRs({
      head: branchName,
      base: baseBranch,
      state: "open",
    });

    if (existingPRs.length > 0 && existingPRs[0]) {
      const existingPR = existingPRs[0];
      console.log(`Updating existing PR #${existingPR.number}...`);

      const pr = await updatePR(existingPR.number, {
        title,
        body,
        labels,
      });

      return {
        success: true,
        pr,
        isUpdate: true,
      };
    }

    console.log("Creating new PR...");
    const pr = await createPR({
      title,
      body,
      head: branchName,
      base: baseBranch,
      labels,
      draft: task.riskLevel === "high", // 高リスクはdraftで作成
    });

    console.log(`PR created: ${pr.url}`);

    return {
      success: true,
      pr,
      isUpdate: false,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.error("Failed to create/update PR:", message);

    return {
      success: false,
      error: message,
    };
  }
}
